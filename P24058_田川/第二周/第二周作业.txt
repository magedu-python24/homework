1. 简要说明Python垃圾回收机制
答：Python里每一个东西都是对象，每个对象都有其对应的内容，并且某个对象被引用时，则它的引用记数就增加，反之，如果这个引用它的对象被删除，则引用记数就减少。当这个对象的引用记数为0时，该对象的生命就结束了，即被垃圾回收。

这个机制的优点：
1）处理简单
2）具有时效性
3）有效释放内存空间

缺点：
1）维护引用记数需消耗系统资源
2）循环引用问题：当一个对象A和一个对象B互相引用，且没有其他的对象对其引用，则对象A和对象B永远无法回收

--------------------------------------------------

2. 什么是斐波那契数列、素数、质数和猴子吃桃问题（文字说明即可）？
答：
1）菲波那切数列：
斐波那契数列又被成为黄金分割数列。该数列由0和1开始，之后的数列就是由之前的两数相加而得出。

2）素数
素数，又被成为质数，指在大于1的自然数中，除了1和该数自身外，无法被其他自然数整除的数。在Python求素数的问题上，有几个比较重要的优化点。第一：去除偶数（2除外，单独打印）；第二：算乘法时的中点，为该数的开方；第三：如果这个质数大于10，则末位一定是1/3/7/9中的一个；第四：一个基数无法被偶数整除。

3）猴子吃桃问题
猴子第一天摘下若干个桃子，当即吃了一半，还不过瘾，又多吃了一个。第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半零一个。到第10天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。
该问题主要的点在于，第10天发现剩余的1个桃子，其实是第九天吃完后剩下的。采用逆推的方式，可以推出每天剩下的桃子等于下一天剩下的桃子+1后再乘以2，循环9次，就是第一天摘下的桃子总数。

--------------------------------------------------

3. 请写出列表支持的所有方法及说明（例如: append 向列表末尾添加元素）
1）列表索引访问
list[index]    index 就是索引

2）列表查询
list.index(value)    从列表中第一个value开始查，匹配到第一个value即刻返回结果。效率慢，尽量不用
list.count(value)    从列表中找到所有符合value值的数量。效率慢，要迭代所有值才返回结果，尽量不用

3）列表元素修改
list[index]=value    将列表中第index个元素修改为value。索引index不能超界

4）列表增加、插入元素
list.append(object)    在列表的尾部追加元素，就地修改，返回值是None。此元素是对象，不管该对象是否可以迭代，都把这个对象看做一个整体的元素增加到列表后面。经常用。

list.insert(index, object)    在列表的第index位置，插入一个元素，返回值也是None，就地修改。此方法效率极低，时间复杂度是O(n)，很少使用

list.extend(iteratable)    在列表的尾部增加可迭代对象，就是将对象中的元素一个一个拿出来，然后增加到尾部，返回值也是None，就地修改。与list.appent()有本质的区别。

+
返回值是list，连接操作，将两个列表连接起来，产生新的报表，原列表不变，本质上是调用_add_()方法。

*
返回值是list，重复操作，将本列表的元素重复n次，返回新的列表，原列表不变。


注意：一般情况下，返回值如果是None，则将自己就地修改；如果有返回值，则返回为创建的一个新的对象，这个新的对象在一个合适的时间进行垃圾回收。

--------------------------------------------------

4. 实现一个简易的计算器，效果如下：
    （1）. 运行后提示让用户输入一个数字
    （2）. 提示输入操作符（+ - * /）
    （3）. 再次提示输入一个数字
    （4）. 打印计算结果
    （5）. 在不退出程序的前提下，可以允许用户继续输入新一组数据计 
答：
while True:
    x = int(input('x = '))
    opt = str(input('operator is '))
    lst = ['+','-','*','/']
    if opt not in lst:
        print('Plz enter the correct operator from + - * /')
        continue
    y = int(input('y = '))
    if opt == '+':
        result = x + y
    elif opt == '-':
        result = x - y
    elif opt == '*':
        result = x * y
    elif opt == '/':
        result = x / y
    print('{}{}{}={}'.format(x,opt,y,result))