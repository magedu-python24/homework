说明列表的浅拷贝和深拷贝的区别
a=[1,2,[1,2]]    原对象
b=a.copy()       浅拷贝
import copy        
c=copy.deepcopy(a)  深拷贝 
a[2][0]=0           更改可变元素
print(id(a[2]))        
print(b,id(b),id(b[2]))
print(c,id(c),id(c[2]))
-》    140344500926856  
-》    [1, 2, [0, 2]] 140344500926536 140344500926856    
-》    [1, 2, [1, 2]] 140344499952584 140344500278664

当拷贝的列表对象中包含有可变元素时，浅拷贝中拷贝的对象的地址空间与原对象的地址空间不一致，但是新对象中的可变元素中的对象的地址和原有对象中可变元素的地址是一致的，只是浅层复制了对象的数据结构，当可变元素中对象改变时，浅拷贝也会跟随变化，而深拷贝则将可变元素的数据结构也进行拷贝。



说明列表和元组的相同点和不同点

相同点：都是序列，可存储丰富的数据类型，可通过索引访问
不同点：列表可变，而元组不可变，元组不可复制


字符串支持的所有方法
join： '@'.join(['1','2','3'])  =》 '1@2@3'    将可迭代对象连接起来，使用@做分隔符
+：    s='s'  t='t'  s+t='st'                  连接字符串
split: 'a,b,c'.split(',') =》 ['a','b','c']    将字符串按照分隔符分割成一个列表
split(sep=None,maxsplit=-1)
   sep:  指定分割字符串，缺省的情况下空白字符串作为分隔符
   maxsplit: 指定分割的次数，-1表示遍历整个字符串

split('@',1):  只切割一下
rsplit('@',1):  从右边切割分隔符
lsplit（'@'）: 从左边切割
splitlines():  按行切割
splitlines(True):  是否保留换行符

partition(sep):  从左至右，遇到分隔符就把字符串分割成两部分，返回头，分隔符，尾三部分的三元组，如果没有找到分隔符，就返回头，2个空元素的三元组

字符串大小写
转换为大写： s.upper()
转换为小写： s.lower()
大小写互换： s.swapcase()

字符串修改
s.replace(old,new,次数)  替换的次数可省略

strip()
从字符串两端去除指定的字符集
如果不指定，去除两端的空白字符

lstrip()
从左端去除指定的字符集

字符串查找
find(sub[,start[,end]])
 在指定的区间[start,end)，从左至右，查找子串sub，找到返回索引，没找到返回-1
a='www.baidu.com'
a.find('w')   查找含有w字符的字符串
a.rfind('w',-8,-1)   逆序查找

index与find类似，但是未找到指定的字符串时将抛出异常

count(sub[,start[,end])   统计字符串出现的次数，可接查找范围

字符串判断
isalnum()  ->  是否是字母和数字组成
isalpha()  ->  是否全是字母
isdigit()  ->  是否全是数字
isidentifier() -> 是不是字母和下划线开头
isupper()  -> 是否全是大写
islower()  ->  是否全是小写
isspace()  ->  是否全是空白字符


字符串格式化
"{},{}".format(*args)  :按照顺序用位置参数替换前面的格式字符串的占位符









