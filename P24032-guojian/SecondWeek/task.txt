1. 简要说明Python垃圾回收机制
在Python中是通过引用计数的方式实现内存管理，当一个对象的引用计数变成0的时候，
说明这个对象已经完成了它的使命，再也用不上了，这个时候Python的垃圾回收机制就
会销毁这个对象，释放内存。
引用计数，当出现以下情况时，引用计数会+1：
当一个对象被创建：a=1
这个对象被引用:   b=a
这个对象被当作参数传入函数中: func(a)
这个对象被存储在容器中：Lst=[a,1,2,3]
与上述情况对应，出现以下情况，引用计数会-1：
当该对象的别名被显式销毁时  del a
当该对象的引别名被赋予新的对象，   a=26
一个对象离开它的作用域，例如 func函数执行完毕时，函数里面的局部变量的引用计数器就会减一（但是全局变量不会）
将该元素从容器中删除时，或者容器被销毁时。


2. 什么是斐波那契数列、素数、质数和猴子吃桃问题（文字说明即可）？
斐波那契数列：
斐波那契数列，又称黄金分割数列、是以兔子繁殖为例子而引入，故又称为兔子数列，
斐波那契数列从第3项开始，每一项等于前两项之和。
素数：
素数又称质数，是指在大于1的自然数中，除了1和它本身，不再能被其它数整除。
猴子吃桃的问题：
猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不过瘾，又多吃了一个，
第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃前一天剩下的一半零一个。
到第10天早上想再吃时，见只剩下一个桃子了。求第一天共摘多少个桃子？
第一天的桃子数量，等于第二天的桃子数量加1然后乘以2
第二天的桃子数量，等于第三天的桃子数量加1然后乘以2
.
.

第九天的桃子数量，等于第十天的桃子数量加1然后乘以2
第十天桃子的数量已知为1个，现在可以倒推第一天桃子的数量 
在不用递归的前提下，程序如下：
#猴子吃桃的问题
s = 1
for i in range(9):
    s = (s + 1) * 2
print(s)

#结果为：1534
3. 请写出列表支持的所有方法及说明（例如: append 向列表末尾添加元素）
del 删除列表
len()获取列表长度
max()返回列表元素最大值
min()返回列表元素最小值
list(seq)将元组转换为列表
list.append() 在列表末尾添加新的对象
list.count()统计某个元素在列表中出现的次数
list.extend(seq) 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）
list.index() 从列表中找出某个值第一个匹配的索引位置
list.insert(index,obj) 将对象插入列表
list.pop([index=-1])移出列表中的一个元素（默认最后一个元素），并且返回该元素的值
list.remove(obj)移除列表中某个值的第一个匹配项
list.reverse() 反向列表中的元素
list.sort(key=None.reverse=False) 对原列表进行排序
list.clear() 清空列表
list.copy() 复制列表
+ 组合俩个列表
* 重复这个列表
in 元素是否存在列表中
for x in [1,2,3,4]  迭代

4. 实现一个简易的计算器，效果如下：
    （1）. 运行后提示让用户输入一个数字
    （2）. 提示输入操作符（+ - * /）
    （3）. 再次提示输入一个数字
    （4）. 打印计算结果
（5）. 在不退出程序的前提下，可以允许用户继续输入新一组数据计 
#简易计算器
while True:
    num1 = int(input('>>>请输入第一个数字：'))
    s = input('>>>请输入操作符：')
    num2 = int(input('>>>请输入第二个数字：'))
    if s == '+':
        num3 = num1 + num2
    elif s == '-':
        num3 = num1 - num2
    elif s == '*':
        num3 = num1 * num2
    elif s == '/':
        num3 = num1 / num2
    print(num3)
