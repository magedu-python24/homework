1. 简要说明Python垃圾回收机制
Python语言默认采用的垃圾收集机制是引用计数法 Reference Counting
『引用计数法』的原理是：每个对象维护一个ob_ref字段，用来记录该对象当前被引用的次数，每当新的引用指向该对象时，它的引用计数ob_ref加1，每当该对象的引用失效时计数ob_ref减1，一旦对象的引用计数为0，该对象立即被回收，对象占用的内存空间将被释放。
它的缺点是需要额外的空间维护引用计数，这个问题是其次的，不过最主要的问题是它不能解决对象的“循环引用”，因此，也有很多语言比如Java并没有采用该算法做来垃圾的收集机制。

2. 什么是斐波那契数列、素数、质数和猴子吃桃问题（文字说明即可）？
3. 请写出列表支持的所有方法及说明（例如: append 向列表末尾添加元素）
     extend(L) #将列表L中所有元素追加到尾部
     insert(index,x) #在index处添加x
     remove(x) #删除第一个值为x的元素
     pop(index) #删除并返回下标为index的元素
     clear() #清空列表
     index(x) #返回列表中第一个值为x的索引
     count(x)  #返回x在列表中出现的次数
     reverse() #对列表进行逆序
     copy() #㳀复制

4. 实现一个简易的计算器，效果如下：
    （1）. 运行后提示让用户输入一个数字
    （2）. 提示输入操作符（+ - * /）
    （3）. 再次提示输入一个数字
    （4）. 打印计算结果
    （5）. 在不退出程序的前提下，可以允许用户继续输入新一组数据计 


a = float(input('输入第一个数'))
b = input('输入操作符')
c = float(input('输入第二个数'))
e = 0.0
while True:
	if b =='+' :
		e = a+c
	elif b == '-':
		e = a-b
	elif b =='*':
        e = a*b
	elif   b == '/':
		if c != 0:
			e = a/b
		else:
			print ('份母不能为0')
	else:
		break
	print ('计算结果为=',e)
	a = e
	b = input('输入操作符')
	c =float(input('输入第二个数'))




