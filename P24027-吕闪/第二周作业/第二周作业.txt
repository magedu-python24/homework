【一：章节学习】
Python环境安装与基础语法：    
        01-Linux环境部署pyenv安装；
        02-pyenv使用和开发环境搭建；
        03-计算机体系和语言分类；
        04-python基础和原反补码及表达式；
        05-GC、分支、循环；
课程习题精讲(1)与Python列表：
        01-位数打印练习和else子句；
        02-习题正方形打印；
        03-阶乘和求质数；
        04-数字处理和列表等内存模型；
        05-列表的基本操作；
课程习题精讲(2)：
        01-九九乘法表各种实现；
        02-九九乘法表变体和菱形变体打印；
        03-斐波那契数列、素数、猴子吃桃问题精讲；
【二：本周作业】：请同学们把作业提交到Github哦~~
1. 简要说明Python垃圾回收机制
2. 什么是斐波那契数列、素数、质数和猴子吃桃问题（文字说明即可）？
3. 请写出列表支持的所有方法及说明（例如: append 向列表末尾添加元素）
4. 实现一个简易的计算器，效果如下：
    （1）. 运行后提示让用户输入一个数字
    （2）. 提示输入操作符（+ - * /）
    （3）. 再次提示输入一个数字
    （4）. 打印计算结果
    （5）. 在不退出程序的前提下，可以允许用户继续输入新一组数据计 
	
【三、作业答案】
【1】.Python的垃圾回收机制是以引用计数（reference count）为主，标记-清除和分代收集两种机制为辅的策略
  （1）引用计数机制：python的每一个东西都是对象，对象的核心就是一个结构体:PyObject,PyObject是每个对象必有的内容，
其中ob_refcnt就是做为引用计数。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少，当引用计数为0时，该对象立即被回收，对象占用的内存空间将被释放。
其中，引用计数+1的情况：
                      1）对象被创建，例如a=23
                      2）对象被引用，例如b=a
                      3）对象被作为参数，传入到一个函数中，例如func(a)
                      4）对象作为一个元素，存储在容器中，例如list1=[a,a]
导致引用计数-1的情况：
                    1）对象的别名被显式销毁，例如del a
                    2）对象的别名被赋予新的对象，例如a=24
                    3）一个对象离开它的作用域，例如f函数执行完毕时，func函数中的局部变量（全局变量不会）
                    4）对象所在的容器被销毁，或从容器中删除对象
优点：简单、实时性好
缺点：需要额外的空间维护引用计数,不能解决对象的“循环引用”
  （2）标记清除（Mark—Sweep）』算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。
它分为两个阶段：第一阶段是标记阶段，GC（Generation Zero；零代）会把所有的『活动对象』打上标记，第二阶段是把那些没有标记的对象『非活动对象』进行回收。
此外，“标记-清除”法是为了解决循环引用问题。可以包含其他对象引用的容器对象（如list, dict, set，甚至class）都可能产生循环引用，
  （3）分代回收是一种以空间换时间的操作方式，Python将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python将内存分为了3“代”，
分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。
gc的逻辑：分配内存
          -> 发现超过阈值了
          -> 触发垃圾回收
          -> 将所有可收集对象链表放到一起
          -> 遍历, 计算有效引用计数
          -> 分成 有效引用计数=0 和 有效引用计数 > 0 两个集合
          -> 大于0的, 放入到更老一代
          -> =0的, 执行回收
          -> 回收遍历容器内的各个元素, 减掉对应元素引用计数(破掉循环引用)
          -> 执行-1的逻辑, 若发现对象引用计数=0, 触发内存回收
          -> python底层内存管理机制回收内存
分代回收同样作为Python的辅助垃圾收集技术处理那些容器对象.
gc模块：gc模块提供一个接口给开发者设置垃圾回收的选项。上面说到，采用引用计数的方法管理内存的一个缺陷是循环引用，而gc模块的一个主要功能就是解决循环引用的问题。

常用函数：

gc.set_debug(flags) 设置gc的debug日志，一般设置为gc.DEBUG_LEAK

gc.collect([generation]) 
显式进行垃圾回收，可以输入参数，0代表只检查第一代的对象，1代表检查一，二代的对象，2代表检查一，二，三代的对象，如果不传参数，执行一个full collection，也就是等于传2。返回不可达（unreachable objects）对象的数目。

gc.set_threshold(threshold0[, threshold1[, threshold2])
设置自动执行垃圾回收的频率。

gc.get_count() 获取当前自动执行垃圾回收的计数器，返回一个长度为3的列表

gc模块的自动垃圾回收机制
必须要import gc模块，并且is_enable()=True才会启动自动垃圾回收。
这个机制的主要作用就是发现并处理不可达的垃圾对象。

垃圾回收=垃圾检查+垃圾回收


gc模块里面会有一个长度为3的列表的计数器，可以通过gc.get_count()获取
自动回收阈值
gc模快有一个自动垃圾回收的阀值，即通过gc.get_threshold函数获取到的长度为3的元组，例如(700,10,10)
每一次计数器的增加，gc模块就会检查增加后的计数是否达到阀值的数目，如果是，就会执行对应的代数的垃圾检查，然后重置计数器

注意：
如果循环引用中，两个对象都定义了__del__方法，gc模块不会销毁这些不可达对象，因为gc模块不知道应该先调用哪个对象的__del__方法，所以为了安全起见，gc模块会把对象放到gc.garbage中，但是不会销毁对象。
【2】
  （1）斐波那契数列：又称黄金分割数列，数学上，斐波纳契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n>=3，n∈N*）
  （2）质数是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。
  （3）猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不过瘾，又多吃了一个 第二天早上又将剩下的桃子吃掉一半，又多吃了一个。
  以后每天早上都吃了前一天剩下的一半零一个。到第10天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少？
【3】列表支持的所有方法及说明
List是由一系列按特定顺序排列的元素组成，是一种可变的、有序的数据集合
list主要有以下几种操作：创建、索引、查询、修改、追加、插入、删除、扩展、统计、排序、获取下标、复制、切片
1.创建空列表：emptylist = []  创建数值列表：列表不能一开始就定义大小
2.索引：索引也叫下表，正索引从左至右，从0开始，负索引从右至左，从-1开始，且正负索引不能超界，否则会引发异常indexError
使用方法：list[下标]
3.查询：
      index(value.[start,stop]),即通过去调用index()这个方法，传入我们需要查询的元素，即可获得该元素在列表中的下标。
      count(value)   返回列表中匹配value的次数、
	  时间复杂度：index、count的时间复杂度是O(n)
	  len() 返回列表元素个数
5.列表的修改：list[index] =  value  索引不能超界
6.列表追加、插入元素：
        append(objects)  列表尾部追加元素，返回None，返回None意味着没有新的列表产生，就地修改，时间复杂度是O(1)
        extend(interable) 将可迭代对象的元素追加进来，返回None
        insert(index,object)  就地修改，时间复杂度是O（n） 超越上界，尾部追加，超越下界，头部追加
		+ - >list 连接两个列表，产生新的列表，原列表不变，本质上调用的是_add_()方法
		* >list  将列表元素重复n次,返回新的列表
7.删除元素：
remove(value)  从左至右找到第一个匹配的值，移除该元素，返回None，就地修改
pop([index])  不指定索引就在尾部弹出一个元素，指定货索引就在索引出弹出一个元素，索引超界报IndexError
clear()  清除所有列表元素，剩余一个空列表
8.反转
reverse() 将列表元素反转，返回None，就地修改
9.排序：
sort(key=None,reverse=False)   对元素进行排序，默认升序，就地修改，reverse为True，反转，降序，key是一个函数，指定key如何排序
sorted(interable,key=None,reverse=False)  返回一个新列表，原列表的顺序不变

10.列表复制
copy() 返回一个新列表
shadow copy  浅拷贝
deepcopy 深拷贝
【4】
简易计算器程序：
def add(x, y):
    return x + y #定义相加
 
def subtract(x, y):
    return x - y  #定义相减
 
def multiply(x, y):
    return x * y #定义相乘
 
def divide(x, y):
    return x / y  #定义相除



while True:
    num1 = float(input('请输入第一个数字'))
    num2 = float(input('请输入第二个数字'))
    choice = input("输入你的选择(1/2/3/4):")
    if choice == '1':
        add_value = add(num1,num2)
        print(num1,"+",num2,"=", "{:.3}".format(add_value)) 
    elif choice == '2':
        subtract_value = subtract(num1,num2)
        print(num1,"-",num2,"=","{:.3}".format(subtract_value))
    elif choice == '3':
        multiply_value = multiply(num1,num2)
        print(num1,"*",num2,"=", "{:.3}".format(multiply_value))
    elif choice == '4':
        divide_value = divide(num1,num2)
        print(num1,"/",num2,"=", "{:.3}".format(divide_value))
    else:
        print("输入数据格式不正确")
	
	












