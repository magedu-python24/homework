1. 集合（set）元素去重的判断依据是什么
    首先判断is是否相等，如果is相等，则一定相同，则去重
    其次判断eq是否相等，再判断hash值是否相等，如果两者都相等，则一定相同。hash值相同有可能是hash值冲突，不一定去重

2. 总结本周视频讲解魔术方法的作用及什么情况会执行到该方法
    new，init，del
        实例化过程中，如果定义了new方法，在首先调用new方法创建实例，并返回本类型实例，然后再调用init方法初始化
        new方法一定要返回本类型实例，否则不调用init方法
        new方法永远是静态方法，如果没有定义，则调用object方法
    bool
        当类中定义了bool方法，则优先调用bool方法，返回值一定为bool值，该方法为实例方法，对类没有影响
        如果类中没有定义bool方法，默认返回true
        len方法返回容器长度，容器为空等价为false，否则等价为true
        如果类中同时定义了bool和len方法，优先调用bool方法，其次len方法，如果两者都没有定义，默认返回true
    可视化
        如果str，format，print直接调用，则优先调用str方法，如果没有定义str方法，则调用repr方法，如果没有定义repr方法，则打印
        内存地址信息。除此之外，则调用repr方法。一般情况下，定义repr方法即可
    运算符重载
        比较运算，数位运算，累运算
    容器方法
        len：内建函数，返回容器长度，值为大于等于0的整数
        iter：迭代容器，返回一个迭代对象
        contains：in成员运算符，遍历iter方法
        getitem：实现self[key]访问
        setitem：实现设置值方法
        missing：使用getitem方法时，key不存在，则调用该方法
    可调用对象
        call方法，类中定义该方法，则实例可以像函数一样调用
    上下文管理
        enter：进入与此对
        象相关的上下文，如果存在该方法，with语法将会把该方法的返回会值绑定到as语句变量上
        exit：退出与对象相关的上下文
    反射
        运行时动态增删类或者实例属性的方式，装饰器和minin是在定义时就确定的，而反射是运行时，具有更大的灵活性
        getattr：通过name获取属性值，如果name不存在，则返回default值，如果default没有定义，则返回属性异常
            当通过搜索实例，类，祖先都不存在时，则调用该方法
        setattr：类属性存在时，则覆盖，否则创建
            当通过.方式增加，修改属性时，都调用该方法
        delattr：通过实例删除属性时，则调用该方法
        hasattr：判断对象是否存在给定名字的属性，名字必须为字符串
        getattribute：实例所有的属性访问，首先调用该方法
    描述器
        当类中定义，set，get，delete中的任意方法，则就是描述器
        只定义了get方法，则是非数据描述器
        定义了set，get方法，则是数据描述器
3. 结合本周所学内容，实现如下类：
    见：作业.py